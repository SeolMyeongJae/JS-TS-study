# ch 6-11 함수

## 함수란?

가장 기본적인 함수의 역할은 코드를 묶는 것이다.

단순히 코드를 묶는 것이 아닌 활용하기 위해 묶는 것이고, 코드를 실행한 결과를 반환한다.

함수는 어떤 목적의 계산을 하는 코드의 묶음이라고 할 수 있고 그 계산을 필요할 때 호출이라고 하는 과정을 통해서 수행 시킬 수 있다.

<br />

## 함수의 원형

함수는 `function` 키워드를 통해 만들 수 있고 `return` 키워드를 통해 실행 결과를 반환할 수 있고 함수의 이름을 통해 호출된다.

```js
// 함수 선언
function myFn() {
  return 100;
}

// 함수 호출
const result = myFn(); // 100
```

함수는 외부로부터 값을 입력받을 수 있는데 이를 인자라고 한다.

인자를 전달받은 함수는 내부에서 인자를 사용하여 결과를 반환할 수 있다.

```js
function myFn(x) {
  return x + 100;
}

const result = myFn(10); // 110
```

자바스크립트의 함수는 유연성이 굉장히 뛰어나 다양한 형태를 가지고 있을 수 있다.

<br />

## 이름 없는 함수

```js
function () {
  return 100;
}
```

이 함수는 이름이 없어서 호출할 수가 없다.

이런 의미없는 함수를 왜 사용할까?

자바스크립트 함수의 특징이 있는데 자바스크립트는 언어 레벨에서 함수를 값으로 취급한다는 것이다.

값으로 취급한다는 건 변수에 넣을 수 있다는 걸 의미한다.

```js
const myFn = function () {
  return 100;
};
```

변수에 함수를 넣게 되면 그 변수가 함수의 이름을 대신하게 된다.

그래서 변수 이름을 사용해 함수를 호출할 수 있게 된다.

```js
myFn();
```

이를 이름 없는 함수, 익명 함수라고 부르고 익명 함수는 반드시 변수에 넣어야 사용할 수 있다.

<br>

## 즉시 실행 함수

이름 없는 함수를 응용한 즉시 실행 함수라는 것이 있다.

즉시 실행 함수는 함수가 만들어지자마자 즉시 한번 실행한다는 의미이다.

```js
(function () {
  console.log('즉시 실행 함수');
})();
```

함수를 값으로 만들기 위해서 괄호로 한번 감싸고 바로 호출 구문이 나오기 때문에 즉시 실행된다.

즉시 실행 함수는 이름이 없기 때문에 다시 호출하고 싶어도 할 수 없다.

즉시 실행 함수는 애플리케이션 내에서 단 한 번만 실행해야 하는 코드가 있을 때 많이 사용하는 테크닉이다.

<br />

## 가변 인자

```js
function myFn(x) {
  return x + 100;
}
```

이 함수에서 x라고 하는 값 하나를 받겠다고 만들어져있다.

하지만 자바스크립트에서는 이 함수를 호출할 때 인자를 2개, 3개, 4개를 보내줘도 정상적으로 호출이 된다.

따라서 함수의 입장에서 2가지 경우의 수를 생각해야 한다.

함수를 호출할 때 인자를 안 줄 수도 있고, 인자를 더 많이 줄 수도 있다.

이런 경우에 어떻게 처리할 것인가에 대한 방법이 필요한데 이를 가변 인자라고 한다.

가변 인자를 이용하면 좀 더 유연한 동작을 하는 함수를 구현할 수 있다.

```js
function sum(a, b, c) {
  return a + b + c;
}
```

sum 함수는 a, b, c를 전달받아 합계를 반환하는 함수이다.

하지만 이 함수를 이용해 값을 4개, 5개를 전달해서 합계를 구하고 싶다는 발상을 할 수도 있다.

이렇게 인자가 가변적일 때도 처리할 수 있는 방법을 자바스크립트가 제공해 준다.

자바스크립트는 함수가 호출될 때 `arguments`라는 유사배열이 전달된다.

함수 내에서 arguments라는 배열을 사용할 수 있는데 이 배열에는 호출 당시에 넘겨받은 인자들을 순서대로 담고 있다.

```js
function sum() {
  let s = 0;
  for (let i = 0; arguments.length; i++) {
    s = s + arguments[i];
  }

  return s;
}

sum(10, 20); // 30
sum(10, 20, 30); // 60
sum(10, 20, 30, 40); // 100
```

이렇게 구현된 함수는 인자가 몇 개가 들어오더라도 arguments배열에 담겨 있기 때문에 원하는 결과를 얻을 수 있다.

하지만 여기서 한 가지 문제가 있는데 이 함수를 사용할 때 함수의 겉모습을 보고서는 가변 인자를 처리하는지 가변 인자를 처리하지 않고 아무런 인자를 안받는 것인지 코드를 직접 보기전에는 알 수 없다.

따라서 함수의 겉모습에 최대한 많은 정보를 표현해 주는 게 중요한데 arguments를 사용하는지 안하는지를 함수를 선언하는 부분에서 표현하는 것이 제한적이다.

그래서 전개 파라미터(rest parameter)라고 하는 스펙이 생기게 되었다.

전개 파라미터는 ...변수명을 주면 된다.

```js
function sum(...args) {
  let s = 0;
  for (let i = 0; arguments.length; i++) {
    s = s + arguments[i];
  }

  return s;
}
```

전개 파라미터를 사용하면 함수를 사용하는 쪽에 인자가 몇 개가 넘어올지 모른다라는 것을 명시적으로 알려줄 수 있다.

<br>

## call & apply

앞에서 함수를 호출하는 구문으로 `()` 이 방법 외에도 두 가지가 더 있는데 `call`과 `apply`를 사용하는 방법이다.

call과 apply는 일반적으로 쓰이는 호출 방법은 아니고 특수한 용도가 있다.

특수한 용도는 자바스크립트 함수 인자와 관련이 있다.

```js
myFn();
myFn.call(null, 10, 20, 30);
myFn.apply(null, [10, 20, 30]);
```

call과 apply는 첫 번째 인자로 context 객체라는 것을 받는다. **context는 나중에 다루기 때문에 우선 null 사용**

call과 apply의 큰 차이점으로 call은 인자를 하나씩 전달해 줘야하고 apply는 인자를 배열에 담아서 전달할 수 있다.

배열에 담아서 전달함으로써 얻을 수 있는 가장 큰 이점은 인자가 늘어나더라도 코드를 직접 수정할 필요가 없다.

```js
const arr = [10, 20, 30, 40, 50];
myFn.call(null, 10, 20, 30, 40, 50);
myFn.apply(null, arr);
```

<br>

## 화살표 함수

먼저 인자를 전달받아 합을 반환하는 함수를 작성하면 다음과 같다.

```js
function sum(a, b) {
  return a + b;
}
```

이를 화살표 함수로 만들면 다음과 같다.

```js
const sum = (a, b) => {
  return a + b;
};
```

화살표 함수는 익명 함수로 작성하기 때문에 호출하기 위해 변수에 넣어 줘야 한다.

화살표 함수를 사용하면 코드를 간소하게 작성할 수 있다는 장점이 있다.

```js
const arrowFn = () => 100;
```

이 함수를 해석하면 인자는 받지 않고 100이라는 값을 반환하는 함수이다.

화살표 함수는 코드가 한 줄이고 그 코드의 결과를 리턴하는 경우 브레이스와 return을 생략할 수 있다.

즉, 위 코드는 다음과 같다.

```js
const arrowFn = () => {
  return 100;
};
```

화살표 함수가 인자를 하나만 받을 때는 괄호를 생략할 수도 있다.

```c
const arrowFn = x => x + 100;
```

<br>

## 제너레이터 함수

일반적인 함수는 호출하면 그 함수로 진입했다가 계산이 끝나면 결과를 반환하고 함수를 종료한다.

제너레이터 함수는 호출하면 함수가 실행되지 않고 실행 준비 상태로만 만든다.

그리고 객체 하나를 반환하는데 그 객체 안에는 함수가 실행 준비를 마쳤으니 그 함수를 실행할 도구를 담은 객체를 반환한다.

그 도구를 이용해서 함수를 실행했다가 멈췄다가 할 수 있다.

```js
function* gen() {}

const g = gen();
```

제너레이터 함수는 `function*`키워드 사용해서 만들 수 있다.

g에는 gen함수를 제어할 객체가 반한된다.

객체에는 하나의 메소드가 들어 있는데 next라고 하는 메소드이다.

이 next 메소드를 사용해서 함수와 커뮤니케이션을 할 수 있게 된다.

값을 줄 수도 있고 함수가 돌려준 값을 받을 수도 있다.

일반 함수에서는 리턴을 사용해서 값을 넘겨줬는데 제너레이터 함수는 yield라는 키워드를 사용해서 값을 반환해준다.

```js
function* gen() {
  yield 10;
  yield 20;
  return 30;
}

const g = gen();

g.next();
g.next();
g.next();
```

next 메소드를 실행하면 yield를 만날 때까지 코드가 실행되고 yield를 만나면 실행이 중단되고 값을 반환한다.

이후에 next를 다시 실행하면 중단되었던 함수 실행이 진행되고 다음 yield를 반환한다.

next를 또 실행하면 return문을 실행하고 함수가 종료된다.

이런식으로 제너레이터 함수는 함수의 내부와 외부를 왔다 갔다하면서 커뮤니케이션을 할 수 있는 스펙을 갖고 있는 특수한 함수이다.
<br>

## 비동기 함수

```js
async function myTask() {}
```

비동기 함수는 비동기 작업을 코드로 구성할 때 Promise라고 하는 스펙을 사용하는데 Promise의 어려운 비동기 코드 구성을 동기적으로 실행되는 방식으로 코드를 작성할 수 있게 만들어주는 함수이다.

**비동기 함수는 Promise와 일급함수라는 것들을 이해하고 더 상세히 학습**
